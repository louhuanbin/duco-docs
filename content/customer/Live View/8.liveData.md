---
title: Live Data
description: Real-time signal visualization for machines in Duco Studio.
navigation:
  icon: i-fluent:pulse-24-filled
---

# Feature Overview

**Live Data** is a core feature within the **Live View** module of **Duco Studio**, designed to visualize real-time data generated during machine operation.

Live Data supports multiple real-time data types, including but not limited to:

- `vehicle_can`
- `vehicle_metrics`

When a machine is running, Live Data monitors signals from `vehicle_can`, `vehicle_metrics`, and other sources with **E2E second-level latency**, and displays them as **dynamic line charts powered by Apache ECharts**.

Each chart supports:

- Single-signal display
- Multi-signal display

This feature is ideal for real-time monitoring of machine status, signal trends, and key performance indicators.

::callout{icon="i-lucide-activity" type="info"}
Live Data provides second-level real-time curves, suitable for live monitoring and issue diagnosis.
::

---

## Getting Started with Live Data

When you enter the Live Data page for the first time, you need to create **Chart Groups (Groups)** for the current machine.

You can initialize your configuration in one of the following ways:

::callout{icon="i-lucide-plus" type="default"}
**Add Group**  
Manually create a chart group
::

::callout{icon="i-lucide-copy" type="default"}
**Select Templates**  
Quickly generate groups using predefined templates
::

Each Group belongs exclusively to the current Machine.

---

## Feature Overview

When entering the Live Data page, the system automatically performs the following actions:

- Queries the current **Machine**
- Uses the **current time zone**
- Loads data from the **last 2 minutes**
- Displays charts for **all Groups** under the current Machine

### Page Preview

::image{src="/images/live_data_list.png" alt="Live Data Overview" width="1200"}
::

---

### Page Controls

#### Group Display & Ordering

- When multiple Groups exist:
  - Use the **up/down arrows** in the top-right corner to adjust the display order of Groups

#### Data Refresh

- Click <Icon name="i-lucide-rotate-ccw" /> **Refresh**
  - Reloads the most recent 2 minutes of data

#### Layout Settings

- Use **Col-1 ~ Col-5**
  - Set the maximum number of charts displayed per row

#### Group Management Actions

::callout{icon="i-lucide-plus"}
**Add Group**  
Create a new chart group manually
::

::callout{icon="i-lucide-copy"}
**Select Templates**  
Generate groups using predefined templates
::

::callout{icon="i-lucide-pencil"}
**Edit Group**  
Modify group configuration
::

::callout{icon="i-lucide-trash-2" type="warning"}
**Delete Group**  
Permanently remove a group
::

---

## Add Group

Click the **Add Group** button in the top-right corner to open the Group configuration dialog.

::image{src="/images/live_data_add_group.png" alt="Live Data Overview" width="1200"}
::

---

### Creating a Group

1. Enter a **Group Name**
2. Click **Add Chart View**
   - Start adding charts to this Group

---

### Chart View Configuration

Each Chart View requires the following configuration:

#### Configuration Fields

1. **Chart Name**
   - Display name of the chart

2. **Display Mode**
   - Single-signal
   - Multi-signal

3. **Signal Selection**
   - Select one or more signals from the dropdown list

4. **Style Settings**
   - `Line Color`: Line color of the chart
   - `Area Color`: Area fill color under the curve

Once configured, the chart is ready to be added to the Group.

---

### Managing Multiple Charts

- Add more charts:
  - Click **Add Chart View** again
- Remove a chart:
  - Click <Icon name="i-lucide-trash-2" />
- Reorder charts within a Group:
  - Use 
  - <Icon name="i-lucide-arrow-up" /> 
  - <Icon name="i-lucide-arrow-down" />

---

### Saving a Group

After completing all configurations, click **Save** in the bottom-right corner:

- The Group will be saved
- All charts will be displayed on the page

---

## Select Templates

Click **Select Templates** in the top-right corner to open the template selection dialog.

::image{src="/images/select_template.png" alt="Live Data Overview" width="1200"}
::

### How It Works

- Templates are carefully curated by the system and provide high-value monitoring scenarios
- Select one or more templates using the checkbox
- Click **Save**

The selected Groups and charts will be automatically loaded onto the page.

---

## Edit Group

Groups created via **Add Group** or **Select Templates** can be modified using **Edit Group**.

Editable properties include:

- Group name
- Number of charts
- Chart names
- Signal selection
- Display mode
- Color styles
- Chart order

The editing workflow is identical to **Add Group**.

---

## Delete Group

If a Group is no longer needed, click **Delete Group** in the top-right corner.

::callout{icon="i-lucide-alert-triangle" type="warning"}
Delete Group performs a permanent deletion. This action cannot be undone.
::


---
# E2E Second-level Live Data Streaming Pipeline

## Processing Overview

This document describes the **end-to-end (E2E) second-level live data processing pipeline** for vehicle **CAN** and **Metrics** signals, covering the full path from data ingestion on the machine to real-time visualization in the frontend via **WebSocket**.

The system is designed to support:

- High-frequency signal collection (1 Hz)
- Tenant isolation
- Per-user and per-field filtering
- Real-time streaming to multiple concurrent users

---

## High-level Data Flow

The overall live data flow is as follows:

1. The machine boots up
2. Raw CAN signals are collected every second
3. Data is validated, parsed, and published to Kafka
4. Live data is distributed via Redis Pub/Sub
5. WebSocket service authenticates frontend users
6. Real-time data is filtered and pushed to clients
7. Grouped ECharts line charts update dynamically

---

## Detailed Flow Description

### 1. Data Collection (Machine Side)

After the machine starts, the **Duco App Service** running on the vehicle performs the following actions:

- Collects raw CAN signals from the CAN bus
- Sampling frequency: **once per second (1 Hz)**
- Sends raw data to the **Ingestion Service**

This stage ensures reliable and continuous signal acquisition directly from the vehicle.

---

### 2. Ingestion & Validation

The **Ingestion Service** is responsible for processing incoming raw data:

- Validates incoming request parameters
- Parses raw CAN frames into structured signal data
- Produces processed data into Kafka topics

**Purpose of this stage:**

- Decouple upstream data collection from downstream consumers
- Enable horizontal scalability
- Improve system fault tolerance

---

### 3. Data Distribution

The **Distributor Service** handles live data fan-out:

- Consumes second-level signal data from Kafka
- Publishes live data using **Redis Pub/Sub**

#### Redis Topic Naming Convention

```bash
live-stream/{tenant}/consumer-{chassisId}/{msgType}

```
Where:

tenant → Tenant isolation

chassisId → Unique machine identifier

msgType → Signal category or message type

## 4. WebSocket Service (Duco Studio)

Duco Studio exposes a **WebSocket server** responsible for:

- Managing frontend connections
- Performing user authentication and authorization
- Handling connection and subscription lifecycles

### Connection Lifecycle

1. The frontend establishes a WebSocket connection
2. Authentication is performed
3. The client sends an initial subscription message containing:
   - User context
   - Machine identifier
   - Required signal fields

#### Example Subscription Payload

```json
{
  "fields": ["speed", "rpm"]
}
```

## 5. Subscription Management (WebSocket Server)

For each active WebSocket connection:

- Required signal fields are stored in memory
- The server subscribes to the corresponding **Redis Pub/Sub topics**
- Multiple users can subscribe to the **same machine** simultaneously

This design enables:

- Efficient fan-out
- Per-user data isolation
- Flexible subscription management

---

## 6. Redis to WebSocket Forwarding

When Redis receives new live data messages, the WebSocket service performs the following steps:

1. Identifies all active WebSocket connections
2. Applies **per-user field filtering** using `pick(fields)`
3. Forwards only the required signal fields to each client

### Benefits

- Reduced payload size
- Per-user and per-field data isolation
- Efficient real-time broadcasting

---

## 7. Frontend Rendering

On the frontend side:

- Second-level live data is received via WebSocket
- Signals are logically grouped
- **ECharts line charts** are dynamically updated
- Near real-time visualization is achieved

---

## Data Processing Characteristics

### Latency

- Approximately **1 second**

### Transport Layers

- **Kafka**: Durable and scalable data streaming
- **Redis Pub/Sub**: Low-latency real-time fan-out
- **WebSocket**: Push-based frontend delivery

### Filtering Strategy

- Per-user
- Per-machine
- Per-field

### Scalability

- Kafka supports horizontal scaling
- Redis Pub/Sub enables efficient real-time distribution
- WebSocket nodes remain stateless (except in-memory subscriptions)

---

## Architecture Diagram (Logical View)

### ASCII Diagram (Markdown-friendly)

```text
+-------------+        +----------------+        +--------+
|   Machine   |        |  Ingestion     |        | Kafka  |
| Duco App    | -----> |  Service       | -----> |        |
| (CAN Data)  |        | (Validate &    |        |        |
+-------------+        |  Parse)        |        +--------+
                       +----------------+
                                |
                                v
                      +------------------+
                      |  Distributor     |
                      |  Service         |
                      +------------------+
                                |
                                v
                       Redis Pub/Sub (Live)
                                |
                                v
                      +------------------+
                      | WebSocket Server |
                      | (Duco Studio)    |
                      +------------------+
                                |
                                v
                      Frontend (ECharts)

```