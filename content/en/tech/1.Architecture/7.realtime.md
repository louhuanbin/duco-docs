---
title: RT Architecture & Data Flow
description: Realtime Architecture and Data flow.
links: []
navigation:
  icon: 
---


## 1. Data Collection

After the machine is **key-on**, the **DUCO App** starts collecting data from the machine **once per second**.

Currently, the **msgType** collected for **Live Data** include:

- **vehicle_can**  
  Full raw data from the CAN bus.  
  This data **requires parsing** before it can be used.

- **client_raw_data**  
  Data that does **not require parsing**, including:
  - DUCO App performance metrics
  - Overall machine application performance data

The DUCO App service connects to **Azure IoT Hub** and sends the collected data to the hub.

---

## 2. Data Processing

### Ingestor Server

The **Ingestor Server** connects to **Azure IoT Hub** and receives the data collected by the DUCO App.

Using parsing logic configured in **MetaAPI**, the raw data is parsed into **human-readable data**.

After parsing:

- One copy of the parsed data is stored in **ClickHouse**
- Another copy is published to **Kafka**
- A real-time copy is published to **Redis Pub/Sub**
  - Topic format: `live-stream/{tenant}/consumer-{chassisId}/{msgType}`

::callout{icon="i-lucide-alert-triangle" type="warning"}
Redis Pub/Sub will be replaced by Redis Streams in the future.
::

---

## 3. Data Consumption

### 3.1 DUCO Studio Server – WebSocket Service

The **DUCO Studio Server** starts a **WebSocket service** to deliver **second-level real-time data** for the **Live Data** page.

The WebSocket URL format is:
`/api/resources/{orgId}/_common/datasets/{chassisId}/live?msgType={msgType}`

When a client connects:
- The WebSocket peer is stored in a `Map` structure , variable as `clientConnections`
- The key is constructed as:
`{chassisId}:{msgType}`

- The peer is added to the corresponding connection set:

```ts
clientConnections.get(key)!.add(peer);
```
- Client Field Mapping per Peer
  > 1. Each peer receives a fieldList from the client.
  > 2. The field list is stored in a Map called clientFields.
  > 3. The peer is used as the key to associate the corresponding field list.
  >  ```ts
  >  clientFields.set(peer, fieldList)
  >  ```

### 3.2 Redis Subscription and Message Dispatching

The **DUCO Studio Server** connects to the **Redis Pub/Sub** service used by the **Distributor Server**.

Based on parameters received from the frontend, the server subscribes to all streams under:

`live-stream/*`
For each message received from Redis:

- 1. The server compares the Redis channel with the user-subscribed channel

- 2. If the channels match, the message is dispatched to all WebSocket peers stored in clientConnections

- 3. Messages are picked by filedList and sent:
```ts
// recieve message from redis
const messageHandler = ({
  channel,
  message
}: {
  channel: string;
  message: string;
}) => {
  if (!channel.startsWith('live-stream/')) return;

  // Channel format example: live-stream/{tenantId}/consumer-{chassisId}/{msgType}
  const match = /^live-stream\/[^/]+\/consumer-([^/]+)\/([^/]+)$/.exec(channel);
  if (!match) {
    logger.warn(
      `${new Date().toISOString().slice(5, 19)} [ws] unexpected channel format: ${channel}`
    );
    return;
  }

  const chassisId = match[1];
  const msgType = match[2] ?? '';
  const key = buildConnectionKey(chassisId, msgType);

  if (key && clientConnections.has(key)) {
    const connections = clientConnections.get(key)!;
    connections.forEach((peer) => {
      try {
        // filter the payload by the filedList
        const filedList = clientFields.get(peer)!;
        const payload = JSON.parse(message).payload;

        const filteredPayload = _.pick(payload, filedList)
        peer.send(JSON.stringify({
          type: 'LIVE_DATA',
          payload: filteredPayload
        }));
      } catch (error) {
        logger.error(
          `${new Date().toISOString().slice(5, 19)} [ws] error sending to client ${key}::${msgType}: ${error}`
        );
        connections.delete(peer);
        try {
          peer.close?.();
        } catch {}
      }
    });
  }
};

```
### 3.3 Live Data Configuration in DUCO Studio Portal

In **DUCO Studio Portal → Live View → Live Data**, users configure **ECharts Line Group** parameters.

After the configuration is completed, the group list is displayed as shown below:

![Group list](/images/live_data_group.png)

For details on how to configure groups, please refer to  [Config Group](/customer/live-view/livedata).


By default, each ECharts line group displays data from the past 2 minutes.

On page initialization, historical data from ClickHouse is loaded and rendered in the charts, providing immediate context before live data streaming starts.

<a id="websocket-init"></a>

### 3.4 WebSocket Initialization on Page Mount

When the **Live Data** page is mounted:

1. Field List Initialization & Filtering via WebSocket
- Retrieve the **fieldList** under the Group configuration List for both:
  - `vehicle_can`
  - `client_raw_data`
- After the WebSocket connection is successfully established, send the retrieved **fieldList** to the WebSocket server.
- The WebSocket server stores the **fieldList** separately on the server side.
- When the socket sends a message, it picks only the requested fields and returns only the required fields to the client.

2. The frontend initializes WebSocket connections by calling the following URLs:


```ts[vehicle_can]
const connectionUrl = `/api/resources/${props.orgId}/_common/datasets/${props.chassisId}/live?msgType=vehicle_can`;
const wsUrl = resolveWebSocketUrl(connectionUrl);

if (!wsUrl) {
  return;
}

client = new WebSocket(wsUrl);
const fieldList = [ // Example
    'speed',
    'engine_rpm',
    'brake_status'
  ];
client.onopen = () => {
  client.send(JSON.stringify({
    type: 'INIT_FIELD_LIST',
    payload: fieldList
  }))
}

```
- **Subscribed Redis topic**: `live-stream/duco/consumer-DUCO_001/vehicle_can`

For metrics data, a separate WebSocket connection is created:

```ts[client_raw_data]
const connectionUrl = `/api/resources/${props.orgId}/_common/datasets/${props.chassisId}/live?msgType=client_raw_data`;
const wsUrl = resolveWebSocketUrl(connectionUrl);

if (!wsUrl) {
  return;
}

metricClient = new WebSocket(wsUrl);
const fieldList = [
    'gps_lat',
    'gps_lng',
    'timestamp'
  ];
metricClient.onopen = () => {
  metricClient.send(JSON.stringify({
    type: 'INIT_FIELD_LIST',
    payload: fieldList
  }))
}

```
- **Subscribed Redis topic**: `live-stream/duco/consumer-DUCO_001/client_raw_data`

After the WebSocket connection is successfully established, the frontend listens
for messages from the server. Each incoming message is parsed and immediately
applied to the corresponding **ECharts line series**, allowing the chart to be
updated dynamically in real time. 

::callout{icon="i-lucide-alert-triangle" type="warning"}
If no data is received within 10 seconds, the connection is considered disconnected by default, and the UI is displayed as offline. If the connection is lost, the user can click the **Refresh** button to reconnect.
::

**Demo Video**
<iframe src="/videos/liveData.mp4" title="Live Data Demo" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen style="aspect-ratio: 16/9; width: 100%;"></iframe>


### 3.5 Real-time Architecture Diagram


::mermaid

flowchart TB
subgraph Machine\["Machine Side"]
  M1\[Machine]
  M2\[DUCO App]
  M1 -->|Collect Raw Data| M2
end
subgraph IOTHub\["Azure IoT Hub"]
  IOT\[Azure IoT Hub]
end
subgraph Metaapi\["Metaapi Server"]
  METAAPI\[API Server]
end
subgraph ingestion\["Ingestion server"]
  ING\[Get Raw Data From IOT Hub]
  RT\[Real-time Raw Data]
  META\[Validate & Parse Raw Data]
  RawData\[Process Raw Data]
end
METAAPI -->|Get Parsed Data Logic| META
subgraph REDISLayer\["Redis"]
  REDIS\[(Redis
  pub/sub)]
end
subgraph KafkaLayer\["Kafka"]
  RawKafka\[(Topic1)]
  KAFKA\[(Other Topics)]
end
subgraph CH\["ClickHouse"]
  CHRaw\[(raw_data_cache_store)]
  CHCe\[(ce_technology)]
end
subgraph Distributor\["Distributor layer"]
  ParsedData\[Get Parsed Data]
end
RawData -->|Store Raw Data| CHRaw
ING -->|Pub All Raw Data | RawKafka
RawKafka -->|Sub All Raw Data | RawData
RawData <-->| Validate and Parse Raw Data| META
M2 -->|Pub Raw Data| IOT
IOT -->|Sub Raw Data| ING
ING -->|Get Real-time Data| RT
RT <--> |Validate and parse Raw Data| META
ParsedData -->|Store All Parsed Data| CHCe
RT -->|Pub parsed Real time Data| REDIS
RawData -->|All Parsed Data -> Pub| KAFKA
KAFKA -->|Sub All Parsed Data| ParsedData
subgraph Studio\["DUCO Studio Server"]
  API\[DUCO Studio API Proxy]
  WS\[WebSocket Service]
end
REDIS -->|Sub live-stream/*| WS
subgraph Frontend\["DUCO Studio Frontend"]
  PAGE\["Live Data Page
UI Mounted"]
  ECHARTS\[ECharts Line Charts]
end
API -->|Initial Echarts data| ECHARTS
CHCe -->|Get 2 min data| API
WS -->|Filtered Live Data| ECHARTS
ECHARTS -->|Render Charts| PAGE
PAGE -->|Create WebSocket and Send INIT_FIELD_LIST| WS

::
<!-- 
  REDIS_S\[(Redis Stream)]
  META -.->|Parsed Data -> stream| REDIS_S
  REDIS_S -.->| Sub stream| WS
  REDIS_S -.->|Get 2 mins data| API
linkStyle 6 stroke:#FFA500,stroke-width:2px
linkStyle 7 stroke:#00aa88,stroke-width:2px
linkStyle 9 stroke:#FFA500,stroke-width:2px
linkStyle 10 stroke:#00aa88,stroke-width:2px
linkStyle 12 stroke:#FFA500,stroke-width:2px
linkStyle 13 stroke:#00aa88,stroke-width:2px -->
---

## 4. Real-Time Data Control via Command

When the UI page is mounted, the page invokes the **MetaAPI** service to start the real-time data stream for the target device.  
The request is first routed through the **DUCO Studio Server API proxy**, which then forwards the call to the MetaAPI service.

**MetaAPI Request:**

```ts[POST /api/iothubs/ducohub/devices/${chassisId}/methods]
{
  "methodName": "setRealTimeUpload",
  "payload": {
    "action":"start",
    "reason": "user_action",
    "commandId": "123e4567-e89b-12d3-a456-426614174000"
  }
}
```

At the same time, the **MetaAPI** service invokes a **Direct Method via Azure IoT Hub** to send a real-time command to the **DUCO App** running on the device.  
After receiving the command, the DUCO App starts the real-time data stream and returns the execution result to the MetaAPI service.  
The MetaAPI service then forwards the result back to the UI page.

Once the real-time data stream is successfully started, the system proceeds with the 
[**3.4 WebSocket Initialization on Page Mount**](#websocket-init)  
workflow to continuously display real-time data on the UI.

---
### 4.1 Heartbeat Mechanism
- The UI page sends a heartbeat request to the MetaAPI service **every 1 minute**.
- If multiple users access the same device simultaneously, the **DUCO Studio Server** aggregates these requests and stores them in **Redis** with a **1-minute TTL**.
- A **cron job** runs every minute:
  - If there are active requests stored in Redis, the server invokes the MetaAPI service to keep the real-time stream active.
  - If there are no active requests in Redis, no invocation is sent.

On the device side, the **DUCO App** also performs heartbeat monitoring:
- If no command is received for more than **3 minutes**, the DUCO App automatically stops the real-time data stream.


### 4.2 Command Architecture Diagram (Logical View)

::mermaid

flowchart TB
subgraph Machine\["Device / Machine Side"]
  APP\[DUCO App]
end
subgraph Cloud\["Azure Cloud"]
  IOT\[Azure IoT Hub
  Direct Method]
end
subgraph MetaAPI\["MetaAPI Service"]
  META\[MetaAPI Server]
end
subgraph Frontend\["DUCO Studio Frontend"]
  PAGE\[Live Data Page
  UI Mounted]
end
subgraph Studio\["DUCO Studio Server"]
  API\[API Proxy]
  CRON\[Cron Job
  Every 1 min]
end
REDIS\[(Redis
      1 min TTL)]
API -->|Forward First Request| META
META -->|Invoke Direct Method| IOT
IOT -->|Command| APP
APP -->|Execution Result| IOT
IOT -->|Result / Ack| META
PAGE -->|Heartbeat 1 min| API
API -->|Store Access| REDIS
REDIS -->|Check Active Requests| CRON
CRON -->|Invoke MetaAPI if Active| META
APP -->|No Command > 3 min 
Stop Stream| APP
::


---














